<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>MementoAI</title>
		<link
			rel="icon"
			href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>ðŸ§ </text></svg>"
		/>

		<!-- PWA Manifest -->
		<link
			rel="manifest"
			href="data:application/json;base64,ewogICAgIm5hbWUiOiAiTWVtZW50b0FJIiwKICAgICJzaG9ydF9uYW1lIjogIk1lbWVudG8iLAogICAgInN0YXJ0X3VybCI6ICIuIiwKICAgICImZGlzcGxheSI6ICJzdGFuZGFsb25lIiwKICAgICJiYWNrZ3JvdW5kX2NvbG9yIjogIiNmYWZhZmEiLAogICAgInRoZW1lX2NvbG9yIjogIiM0YTkwZTUiLAogICAgImRlc2NyaXB0aW9uIjogIkEgY2hhdCBhc3Npc3RhbnQgd2l0aCBsb25nLXRlcm0gbWVtb3J5LiIsCiAgICAiaWNvbnMiOiBbCiAgICAgICAgewogICAgICAgICAgICAic3JjIjogImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCx_YOUR_192x192_ICON_BASE64_HERE_IiwKICAgICAgICAgICAgInNpemVzIjogIjE5MngxOTIiLAogICAgICAgICAgICAidHlwZSI6ICJpbWFnZS9wbmciCiAgICAgICAgfSwKICAgICAgICB7CiAgICAgICAgICAgICJzcmMiOiAiZGF0YTppbWFnZS9wbmc7YmFzZTY0LF9ZT1VSXzUxMng1MTJfSUNPTl9CQVNFNjRfSEVSRV8iLAogICAgICAgICAgICAic2l6ZXMiOiAiNTEyeDUxMiIsCiAgICAgICAgICAgICJ0eXBlIjogImltYWdlL3BuZyIKICAgICAgICB9CiAgICBdCn0K"
		/>

		<!-- Styling -->
		<style>
			:root {
				--primary-color: #4a90e2;
				--bg-color: #fafafa;
				--text-color: #333;
				--user-msg-bg: #e1f5fe;
				--assistant-msg-bg: #f1f1f1;
				--border-color: #ddd;
			}
			body {
				font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
				margin: 0;
				background-color: var(--bg-color);
				color: var(--text-color);
				display: flex;
				flex-direction: column;
				height: 100vh;
			}
			.container {
				max-width: 800px;
				margin: 0 auto;
				width: 100%;
				display: flex;
				flex-direction: column;
				height: 100%;
			}
			header {
				display: flex;
				justify-content: space-between;
				align-items: center;
				padding: 1rem;
				border-bottom: 1px solid var(--border-color);
			}
			h1 {
				margin: 0;
				font-size: 1.5rem;
				color: var(--primary-color);
			}
			#settings-panel {
				padding: 1rem;
				border-bottom: 1px solid var(--border-color);
				background-color: #fff;
			}
			.hidden {
				display: none;
			}
			.form-group {
				margin-bottom: 1rem;
			}
			label {
				display: block;
				margin-bottom: 0.5rem;
				font-weight: bold;
			}
			input[type="text"],
			input[type="password"],
			select,
			textarea {
				width: 100%;
				padding: 0.5rem;
				border: 1px solid var(--border-color);
				border-radius: 4px;
				box-sizing: border-box;
			}
			.form-group small {
				font-size: 0.8rem;
				color: #666;
				margin-top: 4px;
				display: inline-block;
			}
			button {
				padding: 0.5rem 1rem;
				border: none;
				border-radius: 4px;
				background-color: var(--primary-color);
				color: white;
				cursor: pointer;
				transition: background-color 0.2s;
			}
			button:hover {
				background-color: #357abd;
			}
			.button-group {
				display: flex;
				gap: 0.5rem;
				flex-wrap: wrap;
			}
			#chat-container {
				flex-grow: 1;
				padding: 1rem;
				overflow-y: auto;
			}
			.message {
				max-width: 80%;
				padding: 0.75rem;
				border-radius: 8px;
				margin-bottom: 1rem;
				line-height: 1.5;
				white-space: pre-wrap;
			}
			.message.user {
				background-color: var(--user-msg-bg);
				margin-left: auto;
				text-align: left;
			}
			.message.assistant {
				background-color: var(--assistant-msg-bg);
			}
			.message.assistant .model-tag {
				font-size: 0.7rem;
				color: #666;
				font-weight: bold;
				margin-bottom: 0.25rem;
				opacity: 0.8;
			}
			.message.error {
				background-color: #ffebee;
				color: #c62828;
				border-left: 4px solid #c62828;
			}
			footer {
				padding: 1rem;
				border-top: 1px solid var(--border-color);
			}
			#chat-form {
				display: flex;
				gap: 0.5rem;
			}
			#message-input {
				flex-grow: 1;
			}
			#debug-info {
				background-color: #f5f5f5;
				border: 1px solid #ddd;
				padding: 0.5rem;
				margin-top: 1rem;
				font-family: monospace;
				font-size: 0.8rem;
				max-height: 200px;
				overflow-y: auto;
			}
		</style>
	</head>
	<body>
		<div class="container">
			<header>
				<h1>MementoAI</h1>
				<button id="settings-toggle">Settings</button>
			</header>
			<div id="settings-panel" class="hidden">
				<div class="form-group">
					<label for="api-key">OpenRouter API Key</label>
					<input type="password" id="api-key" placeholder="sk-or-..." /><small
						>Your key is saved in your browser's local storage.</small
					>
				</div>
				<div class="form-group">
					<label for="model-select">Model</label>
					<select id="model-select"></select>
				</div>
				<div class="form-group">
					<label> <input type="checkbox" id="free-filter" checked /> Show only free models </label>
				</div>
				<div class="form-group">
					<label for="model-search">Filter models by name</label>
					<input type="text" id="model-search" placeholder="Search model names..." />
				</div>
				<div class="form-group">
					<label for="system-prompt">System Prompt</label><textarea id="system-prompt" rows="12"></textarea>
				</div>
				<div class="button-group">
					<button id="refresh-models">Refresh Models</button>
					<button id="export-memory">Export Memory</button>
					<button id="import-memory">Import Memory</button>
					<button id="enable-notifications">Enable Notifications</button>
					<button id="clear-debug">Clear Debug</button>
					<input type="file" id="import-file-input" accept=".json" style="display: none" />
				</div>
				<div id="debug-info"></div>
			</div>
			<main id="chat-container"></main>
			<footer>
				<form id="chat-form">
					<input type="text" id="message-input" placeholder="Start a conversation..." autocomplete="off" /><button
						type="submit"
					>
						Send
					</button>
				</form>
			</footer>
		</div>

		<script>
			document.addEventListener("DOMContentLoaded", () => {
				// --- DEBUG LOGGING ---
				const debugInfo = document.getElementById("debug-info");
				const log = (message) => {
					console.log(message);
					const timestamp = new Date().toLocaleTimeString();
					debugInfo.innerHTML += `[${timestamp}] ${message}\n`;
					debugInfo.scrollTop = debugInfo.scrollHeight;
				};

				// --- DOM ELEMENTS ---
				const settingsToggle = document.getElementById("settings-toggle");
				const settingsPanel = document.getElementById("settings-panel");
				const apiKeyInput = document.getElementById("api-key");
				const modelSelect = document.getElementById("model-select");
				const freeFilter = document.getElementById("free-filter");
				const modelSearch = document.getElementById("model-search");
				const refreshModelsBtn = document.getElementById("refresh-models");
				const systemPromptTextarea = document.getElementById("system-prompt");
				const exportMemoryBtn = document.getElementById("export-memory");
				const importMemoryBtn = document.getElementById("import-memory");
				const importFileInput = document.getElementById("import-file-input");
				const chatContainer = document.getElementById("chat-container");
				const chatForm = document.getElementById("chat-form");
				const messageInput = document.getElementById("message-input");
				const enableNotificationsBtn = document.getElementById("enable-notifications");
				const clearDebugBtn = document.getElementById("clear-debug");

				// --- APP STATE ---
				let state = {
					conversation: [],
					memory: {
						people: [],
						birthdays: [],
						tasks: [],
						appointments: [],
						health: []
					},
					systemPrompt: `You are MementoAI, a helpful and conversational AI assistant. Your primary goal is to maintain a structured memory for the user. After each response, you MUST parse the user's message for memory changes and provide a JSON object specifying the actions to take.

### Memory Action JSON Format:
Your JSON output must have one or more of the following top-level keys: "add", "update", "delete".

1.  **Adding Items**: Use the "add" key. The value should be an object where keys are memory types (e.g., "tasks") and values are arrays of new items.
    - Example: \`{"add": {"tasks": [{"description": "Buy milk"}]}}\`

2.  **Updating Items**: Use the "update" key. The value is an object where keys are memory types and values are arrays of objects to update. Each object MUST contain the "id" of the item to change and the fields to modify.
    - Example (Marking a task complete): \`{"update": {"tasks": [{"id": "task_1678886400000", "status": "completed"}]}}\`

3.  **Deleting Items**: Use the "delete" key. The value is an object where keys are memory types and values are arrays of "id"s to remove.
    - Example: \`{"delete": {"tasks": ["task_1678886400001"]}}\`

- If no memory changes are needed, return an empty JSON object: \`{}\`.
- ALWAYS provide your conversational response FIRST, followed by \`|||MEMORY|||\`, then the JSON object.

Example interaction:
User: "Hey, can you remind me to submit the report tomorrow? Also, I finished the design mockup task."
(Your memory shows a task with id "task_123" for "Design mockup")
Your Response: Of course, I've added a reminder to submit the report for tomorrow. Great job finishing the mockup!|||MEMORY|||{"add":{"tasks":[{"description":"Submit the report","dueDate":"2025-07-29T23:59:59"}]},"update":{"tasks":[{"id":"task_123","status":"completed"}]}}`,
					reminders: [],
					selectedModel: "",
					allModels: []
				};

				// --- LOCALSTORAGE ---
				const saveState = () => {
					try {
						localStorage.setItem("mementoAIState", JSON.stringify(state));
						log("State saved to localStorage");
					} catch (error) {
						log(`Error saving state: ${error.message}`);
					}
				};

				const loadState = () => {
					try {
						const savedState = localStorage.getItem("mementoAIState");
						if (savedState) {
							state = JSON.parse(savedState);
							log("State loaded from localStorage");
						} else {
							log("No saved state found, using defaults");
						}
						systemPromptTextarea.value = state.systemPrompt;

						// Restore selected model
						if (state.selectedModel) {
							modelSelect.value = state.selectedModel;
							log(`Restored selected model: ${state.selectedModel}`);
						}

						// Restore models if available
						if (state.allModels && state.allModels.length > 0) {
							log(`Restoring ${state.allModels.length} cached models`);
							populateModels(state.allModels);
						}

						renderConversation();
					} catch (error) {
						log(`Error loading state: ${error.message}`);
					}
				};

				const saveApiKey = () => {
					try {
						localStorage.setItem("mementoAI-apiKey", apiKeyInput.value);
						log("API key saved");
					} catch (error) {
						log(`Error saving API key: ${error.message}`);
					}
				};

				const loadApiKey = () => {
					try {
						const savedKey = localStorage.getItem("mementoAI-apiKey");
						if (savedKey) {
							apiKeyInput.value = savedKey;
							log("API key loaded from localStorage");
						} else {
							log("No saved API key found");
						}
					} catch (error) {
						log(`Error loading API key: ${error.message}`);
					}
				};

				// --- UI RENDERING ---
				const addMessageToUI = (role, content, model = null) => {
					const messageDiv = document.createElement("div");
					messageDiv.className = `message ${role}`;

					if (role === "assistant" && model) {
						const modelTag = document.createElement("div");
						modelTag.className = "model-tag";
						modelTag.textContent = model;
						messageDiv.appendChild(modelTag);
					}

					const contentDiv = document.createElement("div");
					contentDiv.textContent = content;
					messageDiv.appendChild(contentDiv);

					chatContainer.appendChild(messageDiv);
					chatContainer.scrollTop = chatContainer.scrollHeight;
				};

				const renderConversation = () => {
					chatContainer.innerHTML = "";
					if (state.conversation) {
						state.conversation.forEach((msg) => {
							addMessageToUI(msg.role, msg.content, msg.model);
						});
					}
				};

				// --- API INTERACTION ---
				const getApiKey = () => {
					const key = apiKeyInput.value.trim();
					if (!key) {
						log("No API key provided");
						alert("Please enter your OpenRouter API key in the settings.");
						return null;
					}
					log("API key retrieved");
					return key;
				};

				// --- MODEL FILTERING ---
				const filterModels = () => {
					if (!state.allModels || state.allModels.length === 0) return;

					const showOnlyFree = freeFilter.checked;
					const searchText = modelSearch.value.toLowerCase().trim();

					const filteredModels = state.allModels.filter((model) => {
						const nameMatch = searchText === "" || model.name.toLowerCase().includes(searchText);
						const freeMatch = !showOnlyFree || model.name.toLowerCase().includes("free");
						return nameMatch && freeMatch;
					});

					log(`Filtered models: ${filteredModels.length} of ${state.allModels.length}`);
					populateModels(filteredModels);
				};

				const populateModels = (models) => {
					const currentSelection = modelSelect.value;
					modelSelect.innerHTML = "";

					models.forEach((model) => {
						const option = document.createElement("option");
						option.value = model.id;
						option.textContent = model.name || model.id;
						modelSelect.appendChild(option);
					});

					// Restore selection if it still exists
					if (currentSelection && models.find((m) => m.id === currentSelection)) {
						modelSelect.value = currentSelection;
					} else if (state.selectedModel && models.find((m) => m.id === state.selectedModel)) {
						modelSelect.value = state.selectedModel;
					}
				};
				const fetchModels = async () => {
					log("Starting to fetch models...");
					const apiKey = getApiKey();
					if (!apiKey) return;

					try {
						log("Making request to OpenRouter models endpoint...");
						const response = await fetch("https://openrouter.ai/api/v1/models", {
							headers: {
								Authorization: `Bearer ${apiKey}`,
								"Content-Type": "application/json"
							}
						});

						log(`Response status: ${response.status} ${response.statusText}`);

						if (!response.ok) {
							const errorText = await response.text();
							log(`API Error Response: ${errorText}`);
							throw new Error(`API Error: ${response.status} ${response.statusText} - ${errorText}`);
						}

						const data = await response.json();
						log(`Received ${data.data ? data.data.length : 0} models`);

						if (data.data && Array.isArray(data.data)) {
							state.allModels = data.data;
							saveState();
							filterModels();
							log("Models fetched and cached successfully");
						} else {
							log("Unexpected response format: " + JSON.stringify(data));
						}
					} catch (error) {
						log(`Error fetching models: ${error.message}`);
						console.error("Failed to fetch models:", error);
						alert(`Error fetching models: ${error.message}`);
					}
				};

				const handleChatSubmit = async (event) => {
					event.preventDefault();
					const userMessage = messageInput.value.trim();
					if (!userMessage) return;

					log(`User message: ${userMessage}`);
					addMessageToUI("user", userMessage);
					state.conversation.push({ role: "user", content: userMessage });
					messageInput.value = "";

					const apiKey = getApiKey();
					if (!apiKey) return;

					const selectedModel = modelSelect.value || "openai/gpt-3.5-turbo";
					log(`Using model: ${selectedModel}`);

					// Save selected model
					state.selectedModel = selectedModel;
					saveState();

					// Construct the system context
					const now = new Date();
					const timeContext = `### CRITICAL TIME CONTEXT\n- UTC Timestamp: ${now.toISOString()}\n- User's Timezone: ${
						Intl.DateTimeFormat().resolvedOptions().timeZone
					}`;
					const memoryContext = `### USER'S CURRENT MEMORY (with IDs)\n${JSON.stringify(state.memory, null, 2)}`;
					const finalSystemMessage = `${state.systemPrompt}\n\n${timeContext}\n\n${memoryContext}`;

					const reinforcementPrompt = {
						role: "system",
						content: `REMINDER: Your task is to respond conversationally AND manage memory. After your text response, you MUST use the "|||MEMORY|||" separator followed by a single, valid JSON object specifying 'add', 'update', or 'delete' actions as defined in the main system prompt. If no actions are needed, use an empty object {}. Now, process the user's following message.`
					};

					const olderConversation = state.conversation.slice(0, -1);
					const latestUserMessage = state.conversation.slice(-1)[0];

					const payload = {
						model: selectedModel,
						messages: [
							{ role: "system", content: finalSystemMessage },
							...olderConversation,
							reinforcementPrompt,
							latestUserMessage
						]
					};

					log("Sending request to chat API...");

					try {
						const response = await fetch("https://openrouter.ai/api/v1/chat/completions", {
							method: "POST",
							headers: {
								Authorization: `Bearer ${apiKey}`,
								"Content-Type": "application/json"
							},
							body: JSON.stringify(payload)
						});

						log(`Chat API response status: ${response.status} ${response.statusText}`);

						if (!response.ok) {
							const errorText = await response.text();
							log(`Chat API Error Response: ${errorText}`);
							throw new Error(`API Error: ${response.status} ${response.statusText} - ${errorText}`);
						}

						const data = await response.json();
						log("Received response from chat API");

						let assistantResponse = data.choices[0].message.content;
						const parts = assistantResponse.split("|||MEMORY|||");
						const conversationalPart = parts[0].trim();

						if (parts.length > 1) {
							try {
								const memoryActions = JSON.parse(parts[1].trim());
								log(`Memory actions: ${JSON.stringify(memoryActions)}`);
								updateMemory(memoryActions);
							} catch (e) {
								log(`Failed to parse memory JSON: ${e.message}`);
								console.error("Failed to parse memory JSON:", e);
							}
						}

						addMessageToUI("assistant", conversationalPart, selectedModel);
						state.conversation.push({ role: "assistant", content: conversationalPart, model: selectedModel });
						saveState();
					} catch (error) {
						log(`Chat API Error: ${error.message}`);
						console.error("Chat API Error:", error);
						addMessageToUI("error", `Error: ${error.message}`);
					}
				};

				// --- MEMORY & REMINDERS ---
				const updateMemory = (actions) => {
					const now = Date.now();
					log(`Updating memory with actions: ${JSON.stringify(actions)}`);

					// Handle Deletions First
					if (actions.delete) {
						for (const type in actions.delete) {
							if (state.memory[type] && Array.isArray(actions.delete[type])) {
								const idsToDelete = new Set(actions.delete[type]);
								state.memory[type] = state.memory[type].filter((item) => !idsToDelete.has(item.id));
							}
						}
					}

					// Handle Updates
					if (actions.update) {
						for (const type in actions.update) {
							if (state.memory[type] && Array.isArray(actions.update[type])) {
								actions.update[type].forEach((updatedItem) => {
									const itemIndex = state.memory[type].findIndex((item) => item.id === updatedItem.id);
									if (itemIndex !== -1) {
										state.memory[type][itemIndex] = { ...state.memory[type][itemIndex], ...updatedItem };
									}
								});
							}
						}
					}

					// Handle Additions Last
					if (actions.add) {
						for (const type in actions.add) {
							if (state.memory[type] && Array.isArray(actions.add[type])) {
								actions.add[type].forEach((newItem, index) => {
									newItem.id = `${type.slice(0, -1)}_${now + index}`;
									state.memory[type].push(newItem);
									if (type === "tasks" && newItem.dueDate) {
										scheduleReminder(newItem.description, new Date(newItem.dueDate), "task");
									}
								});
							}
						}
					}

					log("Memory updated successfully");
					saveState();
				};

				const scheduleReminder = (text, timestamp, type) => {
					const now = new Date();
					const delay = timestamp.getTime() - now.getTime();
					if (delay > 0 && navigator.serviceWorker.controller) {
						navigator.serviceWorker.controller.postMessage({
							type: "schedule-reminder",
							payload: { text: text, delay: delay }
						});
						log(`Reminder scheduled: "${text}"`);
					} else if (delay > 0) {
						log("Using setTimeout fallback for reminder");
						setTimeout(() => {
							if (Notification.permission === "granted") {
								new Notification("MementoAI Reminder", { body: text });
							}
						}, delay);
					}
				};

				const handleNotificationPermission = () => {
					Notification.requestPermission().then((permission) => {
						log(`Notification permission: ${permission}`);
						if (permission === "granted") {
							new Notification("MementoAI", { body: "Notifications are now enabled." });
						}
					});
				};

				const exportMemory = () => {
					try {
						const memoryJson = JSON.stringify(state, null, 2);
						const blob = new Blob([memoryJson], { type: "application/json" });
						const url = URL.createObjectURL(blob);
						const a = document.createElement("a");
						a.href = url;
						a.download = `memento-ai-backup-${new Date().toISOString().split("T")[0]}.json`;
						a.click();
						URL.revokeObjectURL(url);
						log("Memory exported successfully");
					} catch (error) {
						log(`Error exporting memory: ${error.message}`);
					}
				};

				const importMemory = (event) => {
					const file = event.target.files[0];
					if (!file) return;

					const reader = new FileReader();
					reader.onload = (e) => {
						try {
							const importedState = JSON.parse(e.target.result);
							if (importedState.conversation && importedState.memory) {
								state = importedState;
								saveState();
								loadState();
								log("Memory imported successfully");
								alert("Memory imported successfully!");
							} else {
								throw new Error("Invalid file format.");
							}
						} catch (error) {
							log(`Error importing memory: ${error.message}`);
							alert(`Error importing memory: ${error.message}`);
						}
					};
					reader.readAsText(file);
				};

				// --- PWA SERVICE WORKER ---
				const registerServiceWorker = () => {
					if ("serviceWorker" in navigator) {
						navigator.serviceWorker
							.register("sw.js")
							.then(() => log("Service Worker registered successfully"))
							.catch((error) => log(`Service Worker registration failed: ${error.message}`));
					}
				};

				// --- INITIALIZATION ---
				const initializeApp = () => {
					log("Initializing MementoAI...");
					loadApiKey();
					loadState();
					registerServiceWorker();
					fetchModels();

					if (!state.conversation || state.conversation.length === 0) {
						addMessageToUI(
							"assistant",
							"Welcome to MementoAI. Please set your API key and enable notifications in the settings."
						);
					}
					log("Initialization complete");
				};

				// --- EVENT LISTENERS ---
				settingsToggle.addEventListener("click", () => settingsPanel.classList.toggle("hidden"));
				systemPromptTextarea.addEventListener("change", () => {
					state.systemPrompt = systemPromptTextarea.value;
					saveState();
				});
				apiKeyInput.addEventListener("change", saveApiKey);
				modelSelect.addEventListener("change", () => {
					state.selectedModel = modelSelect.value;
					saveState();
					log(`Model selection changed to: ${modelSelect.value}`);
				});
				freeFilter.addEventListener("change", filterModels);
				modelSearch.addEventListener("input", filterModels);
				chatForm.addEventListener("submit", handleChatSubmit);
				refreshModelsBtn.addEventListener("click", fetchModels);
				enableNotificationsBtn.addEventListener("click", handleNotificationPermission);
				exportMemoryBtn.addEventListener("click", exportMemory);
				importMemoryBtn.addEventListener("click", () => importFileInput.click());
				importFileInput.addEventListener("change", importMemory);
				clearDebugBtn.addEventListener("click", () => {
					debugInfo.innerHTML = "";
					log("Debug log cleared");
				});

				initializeApp();
			});
		</script>
	</body>
</html>
