<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>MementoAI</title>
		<link
			rel="icon"
			href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>ðŸ§ </text></svg>"
		/>

		<!-- PWA Manifest -->
		<link
			rel="manifest"
			href="data:application/json;base64,ewogICAgIm5hbWUiOiAiTWVtZW50b0FJIiwKICAgICJzaG9ydF9uYW1lIjogIk1lbWVudG8iLAogICAgInN0YXJ0X3VybCI6ICIuIiwKICAgICImZGlzcGxheSI6ICJzdGFuZGFsb25lIiwKICAgICJiYWNrZ3JvdW5kX2NvbG9yIjogIiNmY2Y4ZjIiLAogICAgInRoZW1lX2NvbG9yIjogIiM4YTY2NjEiLAogICAgImRlc2NyaXB0aW9uIjogIkEgY2hhdCBhc3Npc3RhbnQgd2l0aCBsb25nLXRlcm0gbWVtb3J5LiIsCiAgICAiaWNvbnMiOiBbCiAgICAgICAgewogICAgICAgICAgICAic3JjIjogImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCx_YOUR_192x192_ICON_BASE64_HERE_IiwKICAgICAgICAgICAgInNpemVzIjogIjE5MngxOTIiLAogICAgICAgICAgICAidHlwZSI6ICJpbWFnZS9wbmciCiAgICAgICAgfSwKICAgICAgICB7CiAgICAgICAgICAgICJzcmMiOiAiZGF0YTppbWFnZS9wbmc7YmFzZTY0LF9ZT1VSXzUxMng1MTJfSUNPTl9CQVNFNjRfSEVSRV8iLAogICAgICAgICAgICAic2l6ZXMiOiAiNTEyeDUxMiIsCiAgICAgICAgICAgICJ0eXBlIjogImltYWdlL3BuZyIKICAgICAgICB9CiAgICBdCn0K"
		/>

		<!-- Fonts -->
		<link rel="preconnect" href="https://fonts.googleapis.com" />
		<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
		<link
			href="https://fonts.googleapis.com/css2?family=Crimson+Pro:ital,wght@0,200..900;1,200..900&display=swap"
			rel="stylesheet"
		/>

		<!-- Markdown rendering -->
		<script src="https://cdnjs.cloudflare.com/ajax/libs/marked/4.3.0/marked.min.js"></script>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
		<link
			rel="stylesheet"
			href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github-dark.min.css"
		/>

		<!-- Styling -->
		<style>
			:root {
				--primary-color: #8a6661;
				--bg-color: #fcf8f2;
				--text-color: #5d534a;
				--user-msg-bg: #fff;
				--assistant-msg-bg: #fcf8f2;
				--border-color: #eaddd7;
				--hover-color: #c25546;
			}
			@keyframes fadeInUp {
				from {
					opacity: 0;
					transform: translateY(15px);
				}
				to {
					opacity: 1;
					transform: translateY(0);
				}
			}
			body {
				font-family: "Crimson Pro", serif;
				margin: 0;
				background-color: var(--bg-color);
				color: var(--text-color);
				display: flex;
				flex-direction: column;
				height: 100vh;
			}
			.container {
				max-width: 800px;
				margin: 0 auto;
				width: 100%;
				display: flex;
				flex-direction: column;
				height: 100%;
			}
			header {
				display: flex;
				justify-content: space-between;
				align-items: center;
				padding: 1rem;
				border-bottom: 1px solid var(--border-color);
			}
			h1 {
				margin: 0;
				font-size: 1.5rem;
				color: var(--primary-color);
			}
			#settings-panel {
				padding: 1rem;
				border-bottom: 1px solid var(--border-color);
				background-color: #fffaf5;
			}
			.hidden {
				display: none;
			}
			.form-group {
				margin-bottom: 1rem;
			}
			label {
				display: block;
				margin-bottom: 0.5rem;
				font-weight: bold;
			}
			input[type="text"],
			input[type="password"],
			select,
			textarea {
				width: 100%;
				padding: 0.75rem;
				border: 1px solid var(--border-color);
				border-radius: 8px;
				box-sizing: border-box;
				background-color: #ffffff;
				color: var(--text-color);
				font-family: "Crimson Pro", serif;
				font-size: 1.2rem;
			}
			.form-group small {
				font-size: 0.8rem;
				color: #8c7f76;
				margin-top: 4px;
				display: inline-block;
			}
			button {
				padding: 0.75rem 1.25rem;
				border: none;
				border-radius: 8px;
				background-color: var(--primary-color);
				color: white;
				cursor: pointer;
				transition: background-color 0.2s;
				font-family: "Crimson Pro", serif;
				font-weight: 700; /* Bold weight for buttons */
			}
			button:hover {
				background-color: var(--hover-color);
			}
			.button-group {
				display: flex;
				gap: 0.5rem;
				flex-wrap: wrap;
			}
			#chat-container {
				flex-grow: 1;
				padding: 1rem;
				overflow-y: auto;
			}
			.message {
				max-width: 85%;
				padding: 1rem;
				border-radius: 12px;
				margin-bottom: 1rem;
				line-height: 1.6;
				animation: fadeInUp 0.5s ease-out;
			}
			.message.user {
				background-color: var(--user-msg-bg);
				margin-left: auto;
			}
			.message.assistant {
				background-color: var(--assistant-msg-bg);
				margin-right: auto;
				font-size: 1.1rem;
			}
			.message.assistant .model-tag {
				font-size: 0.7rem;
				color: #666;
				font-weight: bold;
				margin-bottom: 0.25rem;
				opacity: 0.8;
			}
			.message.error {
				background-color: #ffebee;
				color: #c62828;
				border-left: 4px solid #c62828;
				white-space: pre-wrap;
			}
			.previous-conversation summary {
				cursor: pointer;
				padding: 0.5rem 0;
				margin-bottom: 1rem;
				font-style: italic;
				color: #a0938a;
				user-select: none;
			}
			.previous-conversation summary:hover {
				color: var(--text-color);
			}
			.previous-conversation[open] > summary {
				margin-bottom: 1rem;
			}

			/* Markdown styling */
			.message .content h1,
			.message .content h2,
			.message .content h3,
			.message .content h4,
			.message .content h5,
			.message .content h6 {
				margin: 1rem 0 0.5rem 0;
				line-height: 1.2;
				color: #3e3832;
			}
			.message .content p {
				margin: 0.5rem 0;
			}
			.message .content ul,
			.message .content ol {
				margin: 0.5rem 0;
				padding-left: 1.5rem;
			}
			.message .content blockquote {
				border-left: 4px solid var(--border-color);
				margin: 0.5rem 0;
				padding: 0.5rem 1rem;
				background-color: rgba(0, 0, 0, 0.02);
				font-style: italic;
			}
			.message .content code {
				background-color: rgba(0, 0, 0, 0.08);
				padding: 0.2rem 0.4rem;
				border-radius: 4px;
				font-family: "Menlo", "Consolas", monospace;
				font-size: 0.9em;
				color: #2b2622;
			}
			.message .content pre {
				background-color: #2d2d2d;
				border-radius: 8px;
				padding: 1rem;
				margin: 0.5rem 0;
				overflow-x: auto;
				color: #f8f8f2;
			}
			.message .content pre code {
				background-color: transparent;
				padding: 0;
				color: inherit;
			}
			.message .content table {
				border-collapse: collapse;
				width: 100%;
				margin: 1rem 0;
			}
			.message .content th,
			.message .content td {
				border: 1px solid var(--border-color);
				padding: 0.75rem;
				text-align: left;
			}
			.message .content th {
				background-color: var(--user-msg-bg);
			}
			.message .content a {
				color: var(--primary-color);
				text-decoration: underline;
			}
			.message .content a:hover {
				color: var(--hover-color);
			}
			footer {
				padding: 1rem;
				border-top: 1px solid var(--border-color);
				background-color: #fffdf9;
			}
			#chat-form {
				display: flex;
				gap: 0.5rem;
				align-items: flex-end;
			}
			#message-input {
				flex-grow: 1;
				resize: none;
				overflow-y: hidden;
				min-height: 50px; /* Corresponds to button padding + text size */
				max-height: 250px;
				box-sizing: border-box;
				line-height: 1.5;
			}
			#debug-info {
				background-color: #f5f5f5;
				border: 1px solid #ddd;
				padding: 0.5rem;
				margin-top: 1rem;
				font-family: monospace;
				font-size: 0.8rem;
				max-height: 200px;
				overflow-y: auto;
			}
		</style>
	</head>
	<body>
		<div class="container">
			<header>
				<h1>Mitzitant</h1>
				<button id="settings-toggle">Settings</button>
			</header>
			<div id="settings-panel" class="hidden">
				<div class="form-group">
					<label for="api-key">OpenRouter API Key</label>
					<input type="password" id="api-key" placeholder="sk-or-..." /><small
						>Your key is saved in your browser's local storage.</small
					>
				</div>
				<div class="form-group">
					<label for="model-select">Model</label>
					<select id="model-select"></select>
				</div>
				<div class="form-group">
					<label> <input type="checkbox" id="free-filter" checked /> Show only free models </label>
				</div>
				<div class="form-group">
					<label for="model-search">Filter models by name</label>
					<input type="text" id="model-search" placeholder="Search model names..." />
				</div>
				<div class="form-group">
					<label for="system-prompt">System Prompt</label><textarea id="system-prompt" rows="12"></textarea>
				</div>
				<div class="button-group">
					<button id="refresh-models">Refresh Models</button>
					<button id="export-memory">Export Memory</button>
					<button id="import-memory">Import Memory</button>
					<button id="enable-notifications">Enable Notifications</button>
					<button id="clear-debug">Clear Debug</button>
					<input type="file" id="import-file-input" accept=".json" style="display: none" />
				</div>
				<div id="debug-info"></div>
			</div>
			<main id="chat-container"></main>
			<footer>
				<form id="chat-form">
					<textarea id="message-input" rows="1" placeholder="Start a conversation..." autocomplete="off"></textarea>
					<button type="submit">Send</button>
				</form>
			</footer>
		</div>

		<script>
			document.addEventListener("DOMContentLoaded", () => {
				// Configure marked for better markdown rendering
				marked.setOptions({
					highlight: function (code, lang) {
						if (lang && hljs.getLanguage(lang)) {
							try {
								return hljs.highlight(code, { language: lang }).value;
							} catch (err) {}
						}
						return hljs.highlightAuto(code).value;
					},
					breaks: true,
					gfm: true,
					pedantic: false
				});
				// --- DEBUG LOGGING ---
				const debugInfo = document.getElementById("debug-info");
				const log = (message) => {
					console.log(message);
					const timestamp = new Date().toLocaleTimeString();
					debugInfo.innerHTML += `[${timestamp}] ${message}\n`;
					debugInfo.scrollTop = debugInfo.scrollHeight;
				};

				// --- DOM ELEMENTS ---
				const settingsToggle = document.getElementById("settings-toggle");
				const settingsPanel = document.getElementById("settings-panel");
				const apiKeyInput = document.getElementById("api-key");
				const modelSelect = document.getElementById("model-select");
				const freeFilter = document.getElementById("free-filter");
				const modelSearch = document.getElementById("model-search");
				const refreshModelsBtn = document.getElementById("refresh-models");
				const systemPromptTextarea = document.getElementById("system-prompt");
				const exportMemoryBtn = document.getElementById("export-memory");
				const importMemoryBtn = document.getElementById("import-memory");
				const importFileInput = document.getElementById("import-file-input");
				const chatContainer = document.getElementById("chat-container");
				const chatForm = document.getElementById("chat-form");
				const messageInput = document.getElementById("message-input");
				const enableNotificationsBtn = document.getElementById("enable-notifications");
				const clearDebugBtn = document.getElementById("clear-debug");

				// --- APP STATE ---
				let state = {
					conversation: [],
					memory: {
						people: [],
						birthdays: [],
						tasks: [],
						appointments: [],
						health: []
					},
					systemPrompt: `You are MementoAI, a helpful and conversational AI assistant specifically designed to support individuals with ADHD in managing their daily lives, long-term goals, and personal information.

===== SYSTEM FUNCTIONALITY =====
Your primary goal is to maintain a structured memory for the user while providing natural, conversational assistance. You have access to the following capabilities:

1. Persistent Memory Management: Store, update, and retrieve information about people, birthdays, tasks, appointments, and health information.
2. Time Awareness: Access to current time context in ISO 8601 format to provide time-sensitive assistance.
3. Task and Reminder System: Automatically create and manage tasks with due dates and reminders.

===== USER EXPERIENCE GUIDELINES =====
- Communicate naturally and conversationally, as if speaking with a friend
- Be supportive and encouraging without being judgmental
- Help break down complex tasks into manageable steps
- Provide gentle reminders about time management
- Adapt to the user's communication style and preferences
- Focus on what's important to the user right now

===== TIME CONTEXT AWARENESS =====
The current time context is provided in the following standardized format:
- UTC Timestamp: [ISO 8601 UTC format]
- User's Local Time: [ISO 8601 local format]
- User's Timezone: [IANA timezone identifier]

When using time information:
1. Always reference the user's local time when discussing schedules
2. Use the UTC timestamp for any internal processing or record-keeping
3. Be aware of time zone differences when scheduling future events
4. Help the user with time estimation and planning based on the current time

===== MEMORY MANAGEMENT PROTOCOL =====
After each conversational response, you MUST process the user's message for memory changes and provide a JSON object specifying the actions to take.

Memory Action JSON Format:
Your JSON output must have one or more of the following top-level keys: "add", "update", "delete".

1. Adding Items: Use the "add" key. The value should be an object where keys are memory types (e.g., "tasks") and values are arrays of new items.
   Example: {"add": {"tasks": [{"description": "Buy milk"}]}}

2. Updating Items: Use the "update" key. The value is an object where keys are memory types and values are arrays of objects to update. Each object MUST contain the "id" of the item to change and the fields to modify.
   Example (Marking a task complete): {"update": {"tasks": [{"id": "task_1678886400000", "status": "completed"}]}}

3. Deleting Items: Use the "delete" key. The value is an object where keys are memory types and values are arrays of "id"s to remove.
   Example: {"delete": {"tasks": ["task_1678886400001"]}}

- If no memory changes are needed, return an empty JSON object: {}.
- ALWAYS provide your conversational response FIRST, followed by |||MEMORY|||, then the JSON object.
- Ensure all date/time values in memory items use ISO 8601 format (e.g., "2025-07-29T15:30:00")

Example interaction:
User: "Hey, can you remind me to submit the report tomorrow? Also, I finished the design mockup task."
(Your memory shows a task with id "task_123" for "Design mockup")
Your Response: Of course, I've added a reminder to submit the report for tomorrow. Great job finishing the mockup!|||MEMORY|||{"add":{"tasks":[{"description":"Submit the report","dueDate":"2025-07-30T23:59:59"}]},"update":{"tasks":[{"id":"task_123","status":"completed"}]}}`,
					systemPrompt: `You are MementoAI, a helpful and conversational AI assistant. Your primary goal is to maintain a structured memory for the user. After each response, you MUST parse the user's message for memory changes and provide a JSON object specifying the actions to take.

### Memory Action JSON Format:
Your JSON output must have one or more of the following top-level keys: "add", "update", "delete".

1.  **Adding Items**: Use the "add" key. The value should be an object where keys are memory types (e.g., "tasks") and values are arrays of new items.
    - Example: \`{"add": {"tasks": [{"description": "Buy milk"}]}}\`

2.  **Updating Items**: Use the "update" key. The value is an object where keys are memory types and values are arrays of objects to update. Each object MUST contain the "id" of the item to change and the fields to modify.
    - Example (Marking a task complete): \`{"update": {"tasks": [{"id": "task_1678886400000", "status": "completed"}]}}\`

3.  **Deleting Items**: Use the "delete" key. The value is an object where keys are memory types and values are arrays of "id"s to remove.
    - Example: \`{"delete": {"tasks": ["task_1678886400001"]}}\`

- If no memory changes are needed, return an empty JSON object: \`{}\`.
- ALWAYS provide your conversational response FIRST, followed by \`|||MEMORY|||\`, then the JSON object.

Example interaction:
User: "Hey, can you remind me to submit the report tomorrow? Also, I finished the design mockup task."
(Your memory shows a task with id "task_123" for "Design mockup")
Your Response: Of course, I've added a reminder to submit the report for tomorrow. Great job finishing the mockup!|||MEMORY|||{"add":{"tasks":[{"description":"Submit the report","dueDate":"2025-07-29T23:59:59"}]},"update":{"tasks":[{"id":"task_123","status":"completed"}]}}`,
					reminders: [], // Restored
					selectedModel: "",
					allModels: []
				};

				// --- LOCALSTORAGE ---
				const saveState = () => {
					try {
						localStorage.setItem("mementoAIState", JSON.stringify(state));
						log("State saved to localStorage");
					} catch (error) {
						log(`Error saving state: ${error.message}`);
					}
				};

				const loadState = () => {
					try {
						const savedState = localStorage.getItem("mementoAIState");
						if (savedState) {
							state = JSON.parse(savedState);
							log("State loaded from localStorage");
						} else {
							log("No saved state found, using defaults");
						}
						systemPromptTextarea.value = state.systemPrompt;
						if (state.selectedModel) {
							modelSelect.value = state.selectedModel;
							log(`Restored selected model: ${state.selectedModel}`);
						}
						if (state.allModels && state.allModels.length > 0) {
							log(`Restoring ${state.allModels.length} cached models`);
							populateModels(state.allModels);
						}
						renderConversation();
					} catch (error) {
						log(`Error loading state: ${error.message}`);
					}
				};

				const saveApiKey = () => {
					try {
						localStorage.setItem("mementoAI-apiKey", apiKeyInput.value);
						log("API key saved");
					} catch (error) {
						log(`Error saving API key: ${error.message}`);
					}
				};

				const loadApiKey = () => {
					try {
						const savedKey = localStorage.getItem("mementoAI-apiKey");
						if (savedKey) {
							apiKeyInput.value = savedKey;
							log("API key loaded from localStorage");
						} else {
							log("No saved API key found");
						}
					} catch (error) {
						log(`Error loading API key: ${error.message}`);
					}
				};

				// --- UI RENDERING ---
				const collapsePreviousMessages = () => {
					// 1. Find and dismantle any existing collapsible wrapper
					const existingDetails = chatContainer.querySelector("details.previous-conversation");
					if (existingDetails) {
						const parent = existingDetails.parentNode;
						// Move all message elements back to the parent, before the details element
						existingDetails.querySelectorAll(".message").forEach((msg) => {
							parent.insertBefore(msg, existingDetails);
						});
						// Now that it's empty of messages, remove the wrapper
						parent.removeChild(existingDetails);
					}

					// 2. Proceed with the wrapping logic on a clean, flat DOM
					const allMessages = Array.from(chatContainer.querySelectorAll(".message"));
					const lastAssistantMessageIndex = allMessages
						.map((el) => el.classList.contains("assistant"))
						.lastIndexOf(true);

					// If there's no assistant message or only one, no need to collapse
					if (lastAssistantMessageIndex <= 0) {
						return;
					}

					const messagesToCollapse = allMessages.slice(0, lastAssistantMessageIndex);

					if (messagesToCollapse.length > 0) {
						const details = document.createElement("details");
						details.className = "previous-conversation";
						const summary = document.createElement("summary");
						summary.textContent = `View ${messagesToCollapse.length} previous message(s)`;
						details.appendChild(summary);

						messagesToCollapse.forEach((msg) => details.appendChild(msg));

						chatContainer.prepend(details);
					}
				};

				const addMessageToUI = (role, content, model = null) => {
					const messageDiv = document.createElement("div");
					messageDiv.className = `message ${role}`;

					if (role === "assistant" && model) {
						const modelTag = document.createElement("div");
						modelTag.className = "model-tag";
						modelTag.textContent = model;
						messageDiv.appendChild(modelTag);
					}

					const contentDiv = document.createElement("div");
					contentDiv.className = "content";

					if (role === "assistant") {
						contentDiv.innerHTML = marked.parse(content);
					} else {
						contentDiv.textContent = content;
					}

					messageDiv.appendChild(contentDiv);
					chatContainer.appendChild(messageDiv);
					chatContainer.scrollTop = chatContainer.scrollHeight;
				};

				const renderConversation = () => {
					chatContainer.innerHTML = "";
					if (state.conversation) {
						state.conversation.forEach((msg) => {
							addMessageToUI(msg.role, msg.content, msg.model);
						});
					}
					collapsePreviousMessages();
				};

				// --- API INTERACTION ---
				const getApiKey = () => {
					const key = apiKeyInput.value.trim();
					if (!key) {
						log("No API key provided");
						alert("Please enter your OpenRouter API key in the settings.");
						return null;
					}
					log("API key retrieved");
					return key;
				};

				// --- MODEL FILTERING ---
				const filterModels = () => {
					if (!state.allModels || state.allModels.length === 0) return;
					const showOnlyFree = freeFilter.checked;
					const searchText = modelSearch.value.toLowerCase().trim();
					const filteredModels = state.allModels.filter((model) => {
						const nameMatch = searchText === "" || model.name.toLowerCase().includes(searchText);
						const freeMatch = !showOnlyFree || (model.pricing && model.pricing.prompt === "0");
						return nameMatch && freeMatch;
					});
					log(`Filtered models: ${filteredModels.length} of ${state.allModels.length}`);
					populateModels(filteredModels);
				};

				const populateModels = (models) => {
					const currentSelection = modelSelect.value;
					modelSelect.innerHTML = "";
					models.forEach((model) => {
						const option = document.createElement("option");
						option.value = model.id;
						option.textContent = model.name || model.id;
						modelSelect.appendChild(option);
					});
					if (currentSelection && models.find((m) => m.id === currentSelection)) {
						modelSelect.value = currentSelection;
					} else if (state.selectedModel && models.find((m) => m.id === state.selectedModel)) {
						modelSelect.value = state.selectedModel;
					}
				};

				const fetchModels = async () => {
					log("Starting to fetch models...");
					const apiKey = getApiKey();
					if (!apiKey) return;
					try {
						const response = await fetch("https://openrouter.ai/api/v1/models");
						if (!response.ok) {
							const errorText = await response.text();
							throw new Error(`API Error: ${response.status} ${response.statusText} - ${errorText}`);
						}
						const data = await response.json();
						if (data.data && Array.isArray(data.data)) {
							state.allModels = data.data.sort((a, b) => a.name.localeCompare(b.name));
							saveState();
							filterModels();
							log("Models fetched and cached successfully");
						}
					} catch (error) {
						log(`Error fetching models: ${error.message}`);
						alert(`Error fetching models: ${error.message}`);
					}
				};

				// --- TIME CONTEXT GENERATION ---
				const getCurrentTimeContext = () => {
					const now = new Date();
					return `### CRITICAL TIME CONTEXT (Current Time)\n- UTC Timestamp: ${now.toISOString()}\n- User's Local Time: ${now.toLocaleString()}\n- User's Timezone: ${
						Intl.DateTimeFormat().resolvedOptions().timeZone
					}`;
				};

				const handleChatSubmit = async (event) => {
					event.preventDefault();
					const userMessage = messageInput.value.trim();
					if (!userMessage) return;

					// Add user message to state first, then update UI
					state.conversation.push({ role: "user", content: userMessage });
					addMessageToUI("user", userMessage);
					collapsePreviousMessages();

					messageInput.value = "";
					messageInput.style.height = "auto";

					const apiKey = getApiKey();
					if (!apiKey) return;

					const selectedModel = modelSelect.value || "openai/gpt-3.5-turbo";
					log(`Using model: ${selectedModel}`);
					state.selectedModel = selectedModel;

					const memoryContext = `### USER'S CURRENT MEMORY (with IDs)\n${JSON.stringify(state.memory, null, 2)}`;
					const finalSystemMessage = `${state.systemPrompt}\n\n${getCurrentTimeContext()}\n\n${memoryContext}`;
					const reinforcementPrompt = {
						role: "system",
						content: `REMINDER: Your task is to respond conversationally AND manage memory. After your text response, you MUST use the "|||MEMORY|||" separator followed by a single, valid JSON object specifying 'add', 'update', or 'delete' actions. If no actions are needed, use an empty object {}. Now, process the user's following message.\n\n${getCurrentTimeContext()}`
					};

					const messagesForApi = state.conversation.slice();
					messagesForApi.splice(-1, 0, reinforcementPrompt);

					const payload = {
						model: selectedModel,
						messages: [{ role: "system", content: finalSystemMessage }, ...messagesForApi]
					};

					try {
						const response = await fetch("https://openrouter.ai/api/v1/chat/completions", {
							method: "POST",
							headers: {
								Authorization: `Bearer ${apiKey}`,
								"Content-Type": "application/json"
							},
							body: JSON.stringify(payload)
						});

						if (!response.ok) {
							const errorText = await response.text();
							throw new Error(`API Error: ${response.status} ${response.statusText} - ${errorText}`);
						}
						const data = await response.json();
						let assistantResponse = data.choices[0].message.content;
						const parts = assistantResponse.split("|||MEMORY|||");
						const conversationalPart = parts[0].trim();
						if (parts.length > 1) {
							try {
								const memoryActions = JSON.parse(parts[1].trim());
								updateMemory(memoryActions);
							} catch (e) {
								log(`Failed to parse memory JSON: ${e.message}`);
							}
						}

						// Add assistant message to state and UI
						state.conversation.push({ role: "assistant", content: conversationalPart, model: selectedModel });
						addMessageToUI("assistant", conversationalPart, selectedModel);
						collapsePreviousMessages();

						saveState();
					} catch (error) {
						log(`Chat API Error: ${error.message}`);
						addMessageToUI("error", `Error: ${error.message}`);
					}
				};

				// --- MEMORY & REMINDERS (RESTORED) ---
				const updateMemory = (actions) => {
					const now = Date.now();
					log(`Updating memory with actions: ${JSON.stringify(actions)}`);

					// Deletions
					if (actions.delete) {
						for (const type in actions.delete) {
							if (state.memory[type] && Array.isArray(actions.delete[type])) {
								const idsToDelete = new Set(actions.delete[type]);
								state.memory[type] = state.memory[type].filter((item) => !idsToDelete.has(item.id));
							}
						}
					}

					// Updates
					if (actions.update) {
						for (const type in actions.update) {
							if (state.memory[type] && Array.isArray(actions.update[type])) {
								actions.update[type].forEach((updatedItem) => {
									const itemIndex = state.memory[type].findIndex((item) => item.id === updatedItem.id);
									if (itemIndex !== -1) {
										state.memory[type][itemIndex] = { ...state.memory[type][itemIndex], ...updatedItem };
									}
								});
							}
						}
					}

					// Additions
					if (actions.add) {
						for (const type in actions.add) {
							if (state.memory[type] && Array.isArray(actions.add[type])) {
								actions.add[type].forEach((newItem, index) => {
									newItem.id = `${type.slice(0, -1)}_${now + index}`;
									state.memory[type].push(newItem);
									// Check if a reminder needs to be scheduled
									if (type === "tasks" && newItem.dueDate) {
										scheduleReminder(newItem.description, new Date(newItem.dueDate));
									}
								});
							}
						}
					}
					log("Memory updated successfully");
					saveState();
				};

				const scheduleReminder = (text, timestamp) => {
					const now = new Date();
					const delay = timestamp.getTime() - now.getTime();
					if (delay > 0 && navigator.serviceWorker.controller) {
						navigator.serviceWorker.controller.postMessage({
							type: "schedule-reminder",
							payload: { text: text, delay: delay }
						});
						log(`Reminder scheduled via Service Worker: "${text}"`);
					} else if (delay > 0) {
						log("Using setTimeout fallback for reminder");
						setTimeout(() => {
							if (Notification.permission === "granted") {
								new Notification("MementoAI Reminder", { body: text });
							}
						}, delay);
					}
				};

				const handleNotificationPermission = () => {
					Notification.requestPermission().then((permission) => {
						log(`Notification permission: ${permission}`);
						if (permission === "granted") {
							new Notification("MementoAI", { body: "Notifications are now enabled." });
						}
					});
				};

				// --- PWA SERVICE WORKER (RESTORED) ---
				const registerServiceWorker = () => {
					if ("serviceWorker" in navigator) {
						navigator.serviceWorker
							.register("sw.js") // Assumes sw.js is in the root directory
							.then(() => log("Service Worker registered successfully"))
							.catch((error) => log(`Service Worker registration failed: ${error.message}`));
					}
				};

				const exportMemory = () => {
					try {
						const memoryJson = JSON.stringify(state, null, 2);
						const blob = new Blob([memoryJson], { type: "application/json" });
						const url = URL.createObjectURL(blob);
						const a = document.createElement("a");
						a.href = url;
						a.download = `memento-ai-backup-${new Date().toISOString().split("T")[0]}.json`;
						a.click();
						URL.revokeObjectURL(url);
						log("Memory exported successfully");
					} catch (error) {
						log(`Error exporting memory: ${error.message}`);
					}
				};

				const importMemory = (event) => {
					const file = event.target.files[0];
					if (!file) return;
					const reader = new FileReader();
					reader.onload = (e) => {
						try {
							const importedState = JSON.parse(e.target.result);
							if (importedState.conversation && importedState.memory) {
								state = importedState;
								saveState();
								loadState(); // This will call renderConversation()
								log("Memory imported successfully");
								alert("Memory imported successfully!");
							} else {
								throw new Error("Invalid file format.");
							}
						} catch (error) {
							log(`Error importing memory: ${error.message}`);
							alert(`Error importing memory: ${error.message}`);
						}
					};
					reader.readAsText(file);
				};

				// --- INITIALIZATION ---
				const initializeApp = () => {
					log("Initializing MementoAI...");
					loadApiKey();
					loadState();
					fetchModels();
					registerServiceWorker(); // Restored call

					if (!state.conversation || state.conversation.length === 0) {
						addMessageToUI(
							"assistant",
							"Welcome to MementoAI. Please set your API key and enable notifications in the settings."
						);
					}
					log("Initialization complete");
				};

				// --- EVENT LISTENERS ---
				settingsToggle.addEventListener("click", () => settingsPanel.classList.toggle("hidden"));
				systemPromptTextarea.addEventListener("change", () => {
					state.systemPrompt = systemPromptTextarea.value;
					saveState();
				});
				apiKeyInput.addEventListener("change", saveApiKey);
				modelSelect.addEventListener("change", () => {
					state.selectedModel = modelSelect.value;
					saveState();
					log(`Model selection changed to: ${modelSelect.value}`);
				});
				freeFilter.addEventListener("change", filterModels);
				modelSearch.addEventListener("input", filterModels);
				chatForm.addEventListener("submit", handleChatSubmit);
				refreshModelsBtn.addEventListener("click", fetchModels);
				enableNotificationsBtn.addEventListener("click", handleNotificationPermission);
				exportMemoryBtn.addEventListener("click", exportMemory);
				importMemoryBtn.addEventListener("click", () => importFileInput.click());
				importFileInput.addEventListener("change", importMemory);
				clearDebugBtn.addEventListener("click", () => {
					debugInfo.innerHTML = "";
					log("Debug log cleared");
				});

				// Textarea auto-expand and submit logic
				messageInput.addEventListener("input", () => {
					messageInput.style.height = "auto";
					messageInput.style.height = `${messageInput.scrollHeight}px`;
				});

				messageInput.addEventListener("keydown", (e) => {
					if (e.key === "Enter" && !e.shiftKey) {
						e.preventDefault();
						chatForm.dispatchEvent(new Event("submit", { cancelable: true, bubbles: true }));
					}
				});

				initializeApp();
			});
		</script>
	</body>
</html>
